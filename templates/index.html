<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sorteio de ADMs</title>
  <link rel="stylesheet" href="/static/style.css" />
</head>
<body>
  <div class="container">
    <h1>Sorteio de ADMs</h1>
    <p><strong>Bloco alvo:</strong> <span id="spanBlocoAlvo"></span></p>
    <p><strong>Altura atual:</strong> <span id="spanAlturaAtual"></span></p>
    <p><strong>Status:</strong> <span id="spanStatus"></span></p>
    <p><strong>Hash:</strong> <span id="spanHash"></span></p>

    <h2>Participantes</h2>
    <ul id="listaMembros"></ul>
  </div>

  <script>
    let alreadyBuilt = false;       // If we've already built the list
    let previouslyEliminated = [];  // track who was eliminated in the last poll

    function atualizaStatus() {
      fetch('/status.json')
        .then(res => res.json())
        .then(data => {
          const {
            bloco_alvo,
            altura_atual,
            status,
            hash,
            all_members = [],
            eliminados = [],
            restantes = [],
            adms_selecionados = []
          } = data;

          // Update textual info
          document.getElementById('spanBlocoAlvo').textContent = bloco_alvo;
          document.getElementById('spanAlturaAtual').textContent =
            altura_atual ?? 'Indisponível';
          document.getElementById('spanStatus').textContent = status;
          document.getElementById('spanHash').textContent = hash || 'Indisponível';

          // Build the list in original order, but only once
          const ul = document.getElementById('listaMembros');
          if (!alreadyBuilt) {
            ul.innerHTML = ''; // Just to be safe
            all_members.forEach(membro => {
              const li = document.createElement('li');
              li.textContent = membro;
              li.dataset.membro = membro;
              ul.appendChild(li);
            });
            alreadyBuilt = true;

            // Immediately remove already eliminated members
            eliminados.forEach(name => {
              const li = document.querySelector(`li[data-membro="${name}"]`);
              if (li) {
                li.remove();
              }
            });
          }

          // Figure out which members are newly eliminated
          const newEliminations = eliminados.filter(name => !previouslyEliminated.includes(name));

          // Animate out the newly eliminated
          newEliminations.forEach(name => {
            const li = document.querySelector(`li[data-membro="${name}"]`);
            if (li) {
              li.classList.add('removendo');  // trigger CSS transition
              // remove from DOM after the transition is done
              setTimeout(() => li.remove(), 20000); // match your CSS duration
            }
          });

          // For the final winners, highlight them
          if (adms_selecionados.length === 2) {
            adms_selecionados.forEach(winner => {
              const li = document.querySelector(`li[data-membro="${winner}"]`);
              if (li) {
                li.classList.add('vencedor');
              }
            });
          }

          // Update previouslyEliminated
          previouslyEliminated = eliminados;
        })
        .catch(err => console.error("Erro ao obter status:", err));
    }

    atualizaStatus();
    setInterval(atualizaStatus, 300);
  </script>
</body>
</html>